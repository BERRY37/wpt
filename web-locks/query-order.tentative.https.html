<!DOCTYPE html>
<meta charset=utf-8>
<title>Web Locks API: navigator.locks.query ordering</title>
<link rel=help href="https://wicg.github.io/web-locks/">
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="resources/helpers.js"></script>
<style>iframe { display: none; }</style>
<script>
'use strict';

// Grab a lock and hold until a release function is called. Resolves
// to a release function.
function getLockAndHoldUntilReleased(name, options) {
  let release;
  const promise = new Promise(resolve => { release = resolve; });
  return new Promise(resolve => {
    navigator.locks.request(name, options || {}, lock => {
      resolve(release);
      return promise;
    }).catch(_ => {});
  });
}

// Returns a promise resolved by the next message event.
function nextMessage() {
  return new Promise(resolve => {
    window.addEventListener('message', event => {
      resolve(event.data);
    }, {once: true});
  });
}

promise_test(async testCase => {
  const resourceName = uniqueName(testCase);

  // Set up clients.
  const frame1 = await iframe('resources/iframe.html');
  const frame2 = await iframe('resources/iframe.html');
  const frame3 = await iframe('resources/iframe.html');
  testCase.add_cleanup(() => { frame1.remove(); });
  testCase.add_cleanup(() => { frame2.remove(); });
  testCase.add_cleanup(() => { frame3.remove(); });

  // Preemptively take the lock.
  const releaseFunction = await getLockAndHoldUntilReleased(resourceName);

  // Collect the client ids.
  const clientId1 =
      (await postToFrameAndWait(frame1, {op: 'client_id'})).client_id;
  const clientId2 =
      (await postToFrameAndWait(frame2, {op: 'client_id'})).client_id;
  const clientId3 =
      (await postToFrameAndWait(frame3, {op: 'client_id'})).client_id;

  // Queue requested locks from different clients.
  let lockId1;
  let lockId2;
  const lockPromise1 =
      postToFrameAndWait(frame1, {op: 'request', name: resourceName})
          .then(val => {lockId1 = val.lock_id;});
  const lockPromise2 =
      postToFrameAndWait(frame2, {op: 'request', name: resourceName})
          .then(val => {lockId2 = val.lock_id;});
  postToFrameAndWait(frame3, {op: 'request', name: resourceName});

  // Use a checkpoint lock to make sure the other requests are queued before
  // querying state.
  const checkpointId = (await postToFrameAndWait(
                                  frame3,
                                  {op: 'request', name: 'cp'})).lock_id;
  await postToFrameAndWait(frame3, {op: 'release', lock_id: checkpointId});

  // Query the state and test the ordering of requested locks.
  const state = await navigator.locks.query();
  const relevant_pending_ids = state.pending
      .filter(lock => [clientId1, clientId2, clientId3].includes(lock.clientId))
      .map(lock => lock.clientId);
  assert_array_equals(
      [clientId1, clientId2, clientId3],
      relevant_pending_ids,
      'Querying the state should return requested locks in the order they were '
      + 'requested.');

  // Add more requests from the clients in a different order.
  postToFrameAndWait(frame3, {op: 'request', name: resourceName});
  postToFrameAndWait(frame1, {op: 'request', name: resourceName});
  postToFrameAndWait(frame2, {op: 'request', name: resourceName});

  // Release locks such that only the newly added locks are requested. This
  // acts like a checkpoint for the newly queued requests.
  releaseFunction();
  await lockPromise1;
  await postToFrameAndWait(frame1, {op: 'release', lock_id: lockId1});
  await lockPromise2;
  await postToFrameAndWait(frame2, {op: 'release', lock_id: lockId2});

  // Query the state and test the new ordering.
  const state2 = await navigator.locks.query();
  const relevant_pending_ids2 = state2.pending
      .filter(lock => [clientId1, clientId2, clientId3].includes(lock.clientId))
      .map(lock => lock.clientId);
  assert_array_equals(
      [clientId3, clientId1, clientId2],
      relevant_pending_ids2,
      'Querying the state should return requested locks in the order they were '
      + 'requested.');

}, 'Requests appear in state in order made.');
</script>
